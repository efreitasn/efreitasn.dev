<!doctype html><html lang="pt-br"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#0e0e0e"><title>A API inotify do Linux - efreitasn</title><meta name="description" content="Usando inotify com Go."><meta property="og:type" content="article"><meta property="og:url" content="https://efreitasn.dev/pt-BR/posts/inotify-api"><meta property="og:title" content="A API inotify do Linux - efreitasn"><meta property="og:description" content="Usando inotify com Go."><meta property="og:image:url" content="https://efreitasn.dev/assets/4b0ea0fd6cfb37a3793316b024726da7/1920.png"><meta property="og:image:alt" content="Logo do efreitasn.dev"><meta property="article:published_time" content="2020-03-28T07:40:00Z"><meta property="twitter:image:alt" content="Logo do efreitasn.dev"><meta property="twitter:site" content="@efreitasn"><meta property="twitter:creator" content="@efreitasn"><link rel="icon" href="/assets/30ba753e7ca8f6dd067d57b3b85ef622/192.png"><link rel="apple-touch-icon" href="/assets/30ba753e7ca8f6dd067d57b3b85ef622/192.png"><link rel="alternate" hreflang="en" href="https://efreitasn.dev/posts/inotify-api"><link rel="alternate" hreflang="pt-br" href="https://efreitasn.dev/pt-BR/posts/inotify-api"><link rel="stylesheet" href="/assets/style-3fd8bd5ff31a71550f3f56fc034e7a77.css"><script>
  window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) }; ga.l = +new Date;
  ga('create', 'UA-136259822-1', 'auto');
  ga('send', 'pageview');
</script><script async src="https://www.google-analytics.com/analytics.js"></script></head><body><div class="wrapper"><header class="header"><h1 class="header__title"><a href="/pt-BR">efreitasn</a></h1></header><main class="main"><article><header class="post-header"><h1 class="post-header__title">A API inotify do Linux</h1><p class="post-header__dates"><span>Criado:</span>
<time>2020-03-28T07:40:00Z</time><br></p></header><div class="post-content"><p>Recentemente eu criei <a href="https://github.com/efreitasn/wrun">wrun</a>, uma CLI escrita em Go que executa comandos quando há alterações no diretório atual. A abordagem usada para monitorar essas mudanças foi interagir com a API inotify do Linux. Nesse post eu irei dar uma visão geral dessa API em Go usando o package <a href="https://pkg.go.dev/golang.org/x/sys/unix"><code>golang.org/x/sys/unix</code></a>, que fornece abstrações para primitivos de SOs Unix/Unix-like.</p><h2>A API</h2><p>Primeiramente, você cria uma instância:</p><pre class="chroma"><span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">unix</span><span class="p">.</span><span class="nf">InotifyInit1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre><p>O <code>0</code> representa o argumento flags. Esse argumento não será abordado aqui, mas você pode consultar a <a href="http://man7.org/linux/man-pages/man7/inotify.7.html">man page</a> para saber mais sobre ele. <code>fd</code> é um file descriptor que nós usaremos para ler eventos, mas, antes de fazer isso, nós precisamos especificar quais arquivos/diretórios e quais eventos nós desejamos monitorar.</p><pre class="chroma"><span class="nx">wd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">unix</span><span class="p">.</span><span class="nf">InotifyAddWatch</span><span class="p">(</span>
	<span class="nx">fd</span><span class="p">,</span>
	<span class="s">&#34;.&#34;</span><span class="p">,</span>
	<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_CREATE</span><span class="p">|</span>
		<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_DELETE</span><span class="p">|</span>
		<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_CLOSE_WRITE</span><span class="p">|</span>
		<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVED_TO</span><span class="p">|</span>
		<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVED_FROM</span><span class="p">|</span>
		<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVE_SELF</span><span class="p">,</span>
<span class="p">)</span>
</pre><p>Esse código significa que nós estamos monitorando 6 eventos no diretório atual. Como o nome sugere, cada vez que a função <code>unix.InotifyAddWatch()</code> é chamada um watch é adicionado à instância, e esse watch possui um identificador chamado watch descriptor (<code>wd</code>). O <code>wd</code> pode ser usado para remover o watch chamando <code>unix.InotifyRmWatch()</code>.</p><p>Aqui tem alguns comandos e quais eventos eles disparam:</p><pre class="chroma">touch a.txt         <span class="c1"># [IN_CREATE, IN_CLOSE_WRITE]</span>
touch b.txt         <span class="c1"># [IN_CREATE, IN_CLOSE_WRITE]</span>
touch c.txt         <span class="c1"># [IN_CREATE, IN_CLOSE_WRITE]</span>
mkdir dir           <span class="c1"># IN_CREATE</span>
rm a.txt            <span class="c1"># IN_DELETE</span>
<span class="nb">echo</span> cc &gt; c.txt     <span class="c1"># IN_CLOSE_WRITE</span>
mv b.txt dir        <span class="c1"># IN_MOVED_FROM</span>
touch dir/d.txt
rm -r dir           <span class="c1"># IN_DELETE</span>
mv c.txt a.txt      <span class="c1"># [IN_MOVED_FROM, IN_MOVED_TO]</span>
mv <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span> ../dir2   <span class="c1"># IN_MOVE_SELF</span>
<span class="nb">cd</span> ../dir2
touch e.txt         <span class="c1"># [IN_CREATE, IN_CLOSE_WRITE]</span>
</pre><p>Ao monitorar um diretório, inotify não monitora-o de maneira recursiva. Se você quiser esse comportamento, é necessário adicionar cada subdiretório à instância. Além disso, inotify é inode-based, que significa que você pode mudar a localização do arquivo/diretório passado à <code>unix.InotifyAddWatch()</code> e ele continuará sendo monitorado.</p><p>Quando se trata de renomear/mover um arquivo/diretório, há três eventos:</p><ul><li><code>IN_MOVE_SELF</code>: emitido quando o arquivo/diretório sendo monitorado é renomeado/movido.</li><li><code>IN_MOVED_FROM</code>: emitido no antigo diretório pai de um arquivo/diretório que foi renomeado/movido.</li><li><code>IN_MOVED_TO</code>: emitido no novo diretório pai de um arquivo/diretório que foi renomeado/movido.</li></ul><p>Então, se você pretende associar eventos <code>IN_MOVED_FROM</code> com <code>IN_MOVED_TO</code>, você tem que levar em consideração que pode não haver um evento <code>IN_MOVED_TO</code>. Isso acontecerá se o arquivo/diretório foi movido para um diretório que não está sendo monitorado. Uma das soluções para isso é criar um timer (e.g. <code>time.After()</code>). Se um <code>IN_MOVED_TO</code> não for emitido antes de o timer expirar, considere que o arquivo/diretório foi movido para um local não monitorado. Por último, já que esses eventos não são necessariamente sequenciais, cada um deles contém um valor <code>cookie</code> que os relaciona.</p><h3>Lendo eventos</h3><p>Eventos são lidos chamando a função <code>unix.Read()</code> com o <code>fd</code> da instância. Além de um file descriptor, essa função também necessita de um buffer para armazenar os eventos.</p><pre class="chroma"><span class="kd">var</span> <span class="nx">buff</span> <span class="p">[</span><span class="nx">unix</span><span class="p">.</span><span class="nx">SizeofInotifyEvent</span> <span class="o">+</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">NAME_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="kt">byte</span>

<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">unix</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">buff</span><span class="p">[</span><span class="p">:</span><span class="p">]</span><span class="p">)</span>
</pre><p>A constante <code>unix.SizeofInotifyEvent</code> é o tamanho de <code>inotify_event</code>, um struct C que representa um evento. A parte <code>unix.NAME_MAX + 1</code> é relacionada a esse struct conter um <a href="https://wiki.sei.cmu.edu/confluence/display/c/DCL38-C.+Use+the+correct+syntax+when+declaring+a+flexible+array+member">flexible array member</a>. Um campo desse tipo fica localizado no fim do struct, tem um tamanho dinâmico e é ignorado ao calcular o tamanho do struct (<code>unix.SizeofInotifyEvent</code>). Esse é o campo que representa o nome de um arquivo/diretório. <code>unix.NAME_MAX</code> representa o tamanho máximo de um nome de arquivo/diretório, e <code>+ 1</code> tem a ver com essa constante não incluir o caractere <code>NULL</code> presente no fim de uma string C. Portanto, esse tamanho garante que o buffer será capaz de armazenar pelo menos um evento.</p><p>Agora nós precisamos converter os bytes em <code>buff</code> em um ou mais <code>unix.InotifyEvent</code>, que é o equivalente ao struct <code>inotify_event</code>. O problema com essa conversão é o valor de endianess. Em Go, não há uma maneira padrão de obter o valor de endianness do processador, e esse valor é necessário para interpretar os bytes corretamente, já que todos os números no struct são do tipo <code>uint32</code>. Esse problema nos deixa com duas opções: usar o package <code>encoding/binary</code> e encontrar uma maneira de obter o valor de endianness do processador, ou ignorar o type system de Go e usar o endereço de <code>buff[0]</code> como o endereço de um <code>unix.InotifyEvent</code>.</p><p>Vamos primeiro nos lembrar que endianness é como os bytes de um número são ordenados. Há duas ordens: big-endian, que começa com o most significant byte e termina com o least significant, e little-endian, que é o oposto. Por exemplo, <code>0x123456</code> em big-endian fica <code>12</code> <code>34</code> <code>56</code> e em little-endian fica <code>56</code> <code>34</code> <code>12</code>. Uma maneira de descobrir o valor de endianness do processador é verificando como um número <code>uint16</code> é armazenado em memória.</p><pre class="chroma"><span class="kd">func</span> <span class="nf">getEndianness</span><span class="p">(</span><span class="p">)</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">ByteOrder</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">uint16</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">firstByte</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">n</span><span class="p">)</span><span class="p">)</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">firstByte</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span>
<span class="p">}</span>
</pre><p>Agora que há uma maneira de obter o valor de endianness do processador, o package <code>encoding/binary</code> pode ser usado.</p><pre class="chroma"><span class="kd">var</span> <span class="nx">e</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">InotifyEvent</span>

<span class="nx">binary</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span>
	<span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">buff</span><span class="p">[</span><span class="p">:</span><span class="nx">unix</span><span class="p">.</span><span class="nx">SizeofInotifyEvent</span><span class="p">]</span><span class="p">)</span><span class="p">,</span>
	<span class="nf">getEndianness</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="nx">e</span><span class="p">,</span>
<span class="p">)</span>
</pre><p>A segunda opção é menos verbosa e tem a ver com converter o endereço de <code>buff[0]</code> no endereço de um <code>unix.InotifyEvent</code>. Dessa maneira nós não precisamos nos preocupar com endianness.</p><pre class="chroma"><span class="nx">e</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">unix</span><span class="p">.</span><span class="nx">InotifyEvent</span><span class="p">)</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">)</span><span class="p">)</span>
</pre><h4>O nome</h4><p>Se você ver a definição de <code>unix.InotifyEvent</code>, você irá perceber que não há um campo para o nome do arquivo/diretório que causou o evento quando um diretório está sendo monitorado, porém há um campo <code>name</code> no struct original (<code>inotify_event</code>). Então, nós tentaremos criar o nosso próprio struct e ver como as coisas se saem.</p><p>Esse struct terá o mesmo layout que <code>unix.InotifyEvent</code>, porém com a adição de um campo <code>Name</code> no fim. Nós só precisamos decidir que tipo <code>Name</code> terá. O campo no struct original tem o tipo <code>[]char</code>, que representa um flexible array member. Um array de <code>char</code> terminando com <code>NULL</code> é como uma string é representada em C, que é diferente de como uma string é representada em Go. Em Go, uma string é representada por um pointer para seu conteúdo e seu tamanho (length).</p><figure><a href="/assets/inotify-api/d6677901f7ae2fa9b216f8cf7dc09e2f/1280.jpg"><img srcset="/assets/inotify-api/d6677901f7ae2fa9b216f8cf7dc09e2f/425.jpg 425w, /assets/inotify-api/d6677901f7ae2fa9b216f8cf7dc09e2f/640.jpg 640w, /assets/inotify-api/d6677901f7ae2fa9b216f8cf7dc09e2f/960.jpg 960w, /assets/inotify-api/d6677901f7ae2fa9b216f8cf7dc09e2f/1280.jpg 1280w" sizes="(max-width: 26.5625em) calc(100vw - 2.5em), (max-width: 64em) calc(65vw - 2.5em), calc(50vw - 2.5em)" src="/assets/inotify-api/d6677901f7ae2fa9b216f8cf7dc09e2f/1280.jpg" alt="Representação de uma string em C e Go"></a><figcaption>Representação de "abc" em C e Go</figcaption></figure><p>Se nós escolhermos o tipo string, nós não poderemos utilizar a segunda opção para ler eventos devido aos memory layouts entre os structs em C e em Go serem diferentes. A primeira opção também não vai funcionar, já que <code>binary.Read()</code> não aceita um pointer para um struct com um campo de tamanho dinâmico como seu terceiro argumento.</p><p>O outro tipo que faz sentido é <code>[]byte</code>, mas não vai funcionar com nenhuma das opções de leitura pelas mesmas razões do tipo string. O único tipo restante é um array. Um array de <code>byte</code> tem a mesma representação que <code>[]char</code> e um tamanho fixo, porém o problema com um tamanho fixo é que o nome do arquivo/diretório não possui um. Então, nós devemos continuar usando <code>unix.InotifyEvent</code> e encontrar outra maneira de obter o nome.</p><p>Há um campo em <code>unix.InotifyEvent</code> que nos diz o tamanho do nome (<code>Len</code>). Nós podemos usar o valor desse campo para obter um slice de <code>buff</code> e convertê-lo em uma string.</p><pre class="chroma"><span class="nx">name</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buff</span><span class="p">[</span><span class="nx">unix</span><span class="p">.</span><span class="nx">SizeofInotifyEvent</span><span class="p">:</span><span class="nx">unix</span><span class="p">.</span><span class="nx">SizeofInotifyEvent</span><span class="o">+</span><span class="nx">e</span><span class="p">.</span><span class="nx">Len</span><span class="p">]</span><span class="p">)</span>
</pre><p>Sim, não é tão verboso. Eu só queria demonstrar o porquê de não haver um campo <code>Name</code> em <code>unix.InotifyEvent</code>.</p><h5>Caracteres <code>NULL</code></h5><p>Ainda há uma coisa a fazer: remover caracteres <code>NULL</code> do fim do nome. Sempre há pelo menos um caractere <code>NULL</code> devido ao nome ser uma string C, mas pode haver mais para garantir requisitos de alinhamento para os próximos itens no buffer. Apesar de os exemplos anteriores assumirem que o buffer tenha apenas um evento, não quer dizer que não possa haver mais.</p><pre class="chroma"><span class="nx">nameBs</span> <span class="o">:=</span> <span class="nx">buff</span><span class="p">[</span><span class="nx">unix</span><span class="p">.</span><span class="nx">SizeofInotifyEvent</span> <span class="p">:</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">SizeofInotifyEvent</span><span class="o">+</span><span class="nx">e</span><span class="p">.</span><span class="nx">Len</span><span class="p">]</span>
<span class="nx">name</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">TrimRight</span><span class="p">(</span><span class="nx">nameBs</span><span class="p">,</span> <span class="s">&#34;\x00&#34;</span><span class="p">)</span><span class="p">)</span>
</pre><h3>Exemplo completo</h3><pre class="chroma"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>

	<span class="s">&#34;golang.org/x/sys/unix&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">unix</span><span class="p">.</span><span class="nf">InotifyInit1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">unix</span><span class="p">.</span><span class="nf">Close</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">unix</span><span class="p">.</span><span class="nf">InotifyAddWatch</span><span class="p">(</span>
		<span class="nx">fd</span><span class="p">,</span>
		<span class="s">&#34;.&#34;</span><span class="p">,</span>
		<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_CREATE</span><span class="p">|</span>
			<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_DELETE</span><span class="p">|</span>
			<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_CLOSE_WRITE</span><span class="p">|</span>
			<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVED_TO</span><span class="p">|</span>
			<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVED_FROM</span><span class="p">|</span>
			<span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVE_SELF</span><span class="p">,</span>
	<span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">buff</span> <span class="p">[</span><span class="p">(</span><span class="nx">unix</span><span class="p">.</span><span class="nx">SizeofInotifyEvent</span> <span class="o">+</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">NAME_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">]</span><span class="kt">byte</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">offset</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">unix</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">buff</span><span class="p">[</span><span class="p">:</span><span class="p">]</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="nx">offset</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="nx">e</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">unix</span><span class="p">.</span><span class="nx">InotifyEvent</span><span class="p">)</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buff</span><span class="p">[</span><span class="nx">offset</span><span class="p">]</span><span class="p">)</span><span class="p">)</span>

			<span class="nx">nameBs</span> <span class="o">:=</span> <span class="nx">buff</span><span class="p">[</span><span class="nx">offset</span><span class="o">+</span><span class="nx">unix</span><span class="p">.</span><span class="nx">SizeofInotifyEvent</span> <span class="p">:</span> <span class="nx">offset</span><span class="o">+</span><span class="nx">unix</span><span class="p">.</span><span class="nx">SizeofInotifyEvent</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Len</span><span class="p">)</span><span class="p">]</span>
			<span class="nx">name</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">TrimRight</span><span class="p">(</span><span class="nx">nameBs</span><span class="p">,</span> <span class="s">&#34;\x00&#34;</span><span class="p">)</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Mask</span><span class="o">&amp;</span><span class="nx">unix</span><span class="p">.</span><span class="nx">IN_ISDIR</span> <span class="o">==</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">IN_ISDIR</span> <span class="p">{</span>
				<span class="nx">name</span> <span class="o">+=</span> <span class="s">&#34; (dir)&#34;</span>
			<span class="p">}</span>

			<span class="k">switch</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Mask</span><span class="o">&amp;</span><span class="nx">unix</span><span class="p">.</span><span class="nx">IN_CREATE</span> <span class="o">==</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">IN_CREATE</span><span class="p">:</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;CREATE %v\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Mask</span><span class="o">&amp;</span><span class="nx">unix</span><span class="p">.</span><span class="nx">IN_DELETE</span> <span class="o">==</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">IN_DELETE</span><span class="p">:</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;DELETE %v\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Mask</span><span class="o">&amp;</span><span class="nx">unix</span><span class="p">.</span><span class="nx">IN_CLOSE_WRITE</span> <span class="o">==</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">IN_CLOSE_WRITE</span><span class="p">:</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;CLOSE_WRITE %v\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Mask</span><span class="o">&amp;</span><span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVED_TO</span> <span class="o">==</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVED_TO</span><span class="p">:</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;IN_MOVED_TO [%v] %v\n&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Cookie</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Mask</span><span class="o">&amp;</span><span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVED_FROM</span> <span class="o">==</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVED_FROM</span><span class="p">:</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;IN_MOVED_FROM [%v] %v\n&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Cookie</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Mask</span><span class="o">&amp;</span><span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVE_SELF</span> <span class="o">==</span> <span class="nx">unix</span><span class="p">.</span><span class="nx">IN_MOVE_SELF</span><span class="p">:</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;IN_MOVE_SELF %v\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="nx">offset</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">unix</span><span class="p">.</span><span class="nx">SizeofInotifyEvent</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Len</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre><h2>Referências</h2><p>Aqui tem uma lista de links que eu usei como referências e/ou estendem o que eu falei sobre alguns conceitos:</p><ul><li><a href="http://man7.org/linux/man-pages/man7/inotify.7.html">http://man7.org/linux/man-pages/man7/inotify.7.html</a></li><li><a href="https://developer.ibm.com/technologies/systems/articles/au-endianc/">https://developer.ibm.com/technologies/systems/articles/au-endianc/</a></li><li><a href="https://www.gnu.org/software/libc/manual/html_node/Limits-for-Files.html">https://www.gnu.org/software/libc/manual/html_node/Limits-for-Files.html</a></li><li><a href="http://blog.golang.org/slices-intro">http://blog.golang.org/slices-intro</a></li><li><a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a></li><li><a href="https://blog.golang.org/slices">https://blog.golang.org/slices</a></li><li><a href="https://research.swtch.com/godata">https://research.swtch.com/godata</a></li><li><a href="http://inotify.aiken.cz/">http://inotify.aiken.cz/</a></li><li><a href="https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf">https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf</a></li></ul></div><footer class="post-footer"><a href="https://github.com/efreitasn/efreitasn.dev/blob/master/content/posts/inotify-api/content_pt-BR.md">Editar no GitHub</a></footer></article></main><footer class="footer"><nav class="footer-nav"><ul><li><a href="https://github.com/efreitasn/efreitasn.dev">GitHub</a></li><li><a href="/pt-BR/posts/about">Sobre</a></li><li><a href="/posts/inotify-api">English</a></li></ul></nav></footer></div></body></html>